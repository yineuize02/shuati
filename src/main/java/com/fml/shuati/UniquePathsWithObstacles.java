package com.fml.shuati;

/** dp https://leetcode-cn.com/problems/unique-paths-ii/ */
public class UniquePathsWithObstacles {

  public static void main(String[] args) {
    //

    var tt = new UniquePathsWithObstacles();
    System.out.println(tt.uniquePathsWithObstacles(new int[][] {{1, 0}}));

    System.out.println(tt.uniquePathsWithObstacles(new int[][] {{0}}));
    System.out.println(tt.uniquePathsWithObstacles(new int[][] {{1}}));
    System.out.println(tt.uniquePathsWithObstacles(new int[][] {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}}));
    System.out.println(tt.uniquePathsWithObstacles(new int[][] {{0, 1}, {0, 0}}));
    System.out.println(
        tt.uniquePathsWithObstacles(
            new int[][] {
              {0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
              {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0},
              {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1},
              {0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
              {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0},
              {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0},
              {1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
              {0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0},
              {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
              {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0},
              {0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
              {0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
              {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1},
              {0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
              {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
              {1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0},
              {0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0},
              {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
              {0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
              {0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0},
              {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1},
              {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0},
              {1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
              {0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
              {0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0},
              {1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1},
              {1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}
            }));
  }

  public int uniquePathsWithObstacles(int[][] obstacleGrid) {

    // ++---------+----------+---------+----------+
    // |   m,n   |   m,n-1  |         |   m,0     |
    // |         |          |         |           |
    // +------------------------------------------+
    // |  m-1,0  |          |         |  m-1,0    |
    // |         |          |         |           |
    // +------------------------------------------+
    // |   1,0   |          |         |   1,0     |
    // |         |          |         |           |
    // +------------------------------------------+
    // |         |          |         |           +
    // |  0,n    |  0,n-1     |  0,1  |    0,0    |
    // |         |          |         |           |
    // |         |          |         |           |
    // +---------+----------+---------+-----------+
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;

    // m行 n列
    int[][] dp = new int[m][n];

    if (n == 0) {
      return 0;
    }

    dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;
    if (dp[0][0] == 0) {
      return 0;
    }

    if (m > 1) {
      dp[1][0] = obstacleGrid[1][0] == 0 ? 1 : 0;
    }

    if (n > 1) {
      dp[0][1] = obstacleGrid[0][1] == 0 ? 1 : 0;
    }

    for (int i = 2; i < m; i++) {
      if (obstacleGrid[i][0] == 1) {
        dp[i][0] = 0;
      } else {
        dp[i][0] = dp[i - 1][0];
      }
    }
    for (int j = 2; j < n; j++) {
      if (obstacleGrid[0][j] == 1) {
        dp[0][j] = 0;

      } else {
        dp[0][j] = dp[0][j - 1];
      }
    }

    for (int i = 1; i < m; ++i) {
      for (int j = 1; j < n; ++j) {

        if (obstacleGrid[i][j] == 0) {
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
      }
    }

    return dp[m - 1][n - 1];
  }
}
